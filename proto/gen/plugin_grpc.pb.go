// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: plugin.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ExecSessionService_Output_FullMethodName = "/hashicorp.waypoint.sdk.ExecSessionService/Output"
	ExecSessionService_Input_FullMethodName  = "/hashicorp.waypoint.sdk.ExecSessionService/Input"
)

// ExecSessionServiceClient is the client API for ExecSessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Exec is a service that a work *component.ExecSessionInfo
// to plugins. Plugins don't interact with this directly, they usually
// interact with it indirectly via a *component.ExecSessionInfo.
type ExecSessionServiceClient interface {
	Output(ctx context.Context, in *ExecSession_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Input(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecSession_InputRequest], error)
}

type execSessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExecSessionServiceClient(cc grpc.ClientConnInterface) ExecSessionServiceClient {
	return &execSessionServiceClient{cc}
}

func (c *execSessionServiceClient) Output(ctx context.Context, in *ExecSession_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ExecSessionService_Output_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execSessionServiceClient) Input(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecSession_InputRequest], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ExecSessionService_ServiceDesc.Streams[0], ExecSessionService_Input_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, ExecSession_InputRequest]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ExecSessionService_InputClient = grpc.ServerStreamingClient[ExecSession_InputRequest]

// ExecSessionServiceServer is the server API for ExecSessionService service.
// All implementations must embed UnimplementedExecSessionServiceServer
// for forward compatibility.
//
// Exec is a service that a work *component.ExecSessionInfo
// to plugins. Plugins don't interact with this directly, they usually
// interact with it indirectly via a *component.ExecSessionInfo.
type ExecSessionServiceServer interface {
	Output(context.Context, *ExecSession_OutputRequest) (*emptypb.Empty, error)
	Input(*emptypb.Empty, grpc.ServerStreamingServer[ExecSession_InputRequest]) error
	mustEmbedUnimplementedExecSessionServiceServer()
}

// UnimplementedExecSessionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExecSessionServiceServer struct{}

func (UnimplementedExecSessionServiceServer) Output(context.Context, *ExecSession_OutputRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Output not implemented")
}
func (UnimplementedExecSessionServiceServer) Input(*emptypb.Empty, grpc.ServerStreamingServer[ExecSession_InputRequest]) error {
	return status.Errorf(codes.Unimplemented, "method Input not implemented")
}
func (UnimplementedExecSessionServiceServer) mustEmbedUnimplementedExecSessionServiceServer() {}
func (UnimplementedExecSessionServiceServer) testEmbeddedByValue()                            {}

// UnsafeExecSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecSessionServiceServer will
// result in compilation errors.
type UnsafeExecSessionServiceServer interface {
	mustEmbedUnimplementedExecSessionServiceServer()
}

func RegisterExecSessionServiceServer(s grpc.ServiceRegistrar, srv ExecSessionServiceServer) {
	// If the following call pancis, it indicates UnimplementedExecSessionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExecSessionService_ServiceDesc, srv)
}

func _ExecSessionService_Output_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecSession_OutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecSessionServiceServer).Output(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecSessionService_Output_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecSessionServiceServer).Output(ctx, req.(*ExecSession_OutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecSessionService_Input_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecSessionServiceServer).Input(m, &grpc.GenericServerStream[emptypb.Empty, ExecSession_InputRequest]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ExecSessionService_InputServer = grpc.ServerStreamingServer[ExecSession_InputRequest]

// ExecSessionService_ServiceDesc is the grpc.ServiceDesc for ExecSessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExecSessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.ExecSessionService",
	HandlerType: (*ExecSessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Output",
			Handler:    _ExecSessionService_Output_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Input",
			Handler:       _ExecSessionService_Input_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "plugin.proto",
}

const (
	LogViewer_NextLogBatch_FullMethodName = "/hashicorp.waypoint.sdk.LogViewer/NextLogBatch"
)

// LogViewerClient is the client API for LogViewer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// LogViewer returns batches of log lines for a single app deployed
// on a platform (though that app may itself have multiple instances).
// This service is used exclusively internally across the plugin boundary
// for mapping the component.LogViewer value into a plugin's LogsFunc()
type LogViewerClient interface {
	NextLogBatch(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Logs_NextBatchResp, emptypb.Empty], error)
}

type logViewerClient struct {
	cc grpc.ClientConnInterface
}

func NewLogViewerClient(cc grpc.ClientConnInterface) LogViewerClient {
	return &logViewerClient{cc}
}

func (c *logViewerClient) NextLogBatch(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Logs_NextBatchResp, emptypb.Empty], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LogViewer_ServiceDesc.Streams[0], LogViewer_NextLogBatch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Logs_NextBatchResp, emptypb.Empty]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LogViewer_NextLogBatchClient = grpc.ClientStreamingClient[Logs_NextBatchResp, emptypb.Empty]

// LogViewerServer is the server API for LogViewer service.
// All implementations must embed UnimplementedLogViewerServer
// for forward compatibility.
//
// LogViewer returns batches of log lines for a single app deployed
// on a platform (though that app may itself have multiple instances).
// This service is used exclusively internally across the plugin boundary
// for mapping the component.LogViewer value into a plugin's LogsFunc()
type LogViewerServer interface {
	NextLogBatch(grpc.ClientStreamingServer[Logs_NextBatchResp, emptypb.Empty]) error
	mustEmbedUnimplementedLogViewerServer()
}

// UnimplementedLogViewerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLogViewerServer struct{}

func (UnimplementedLogViewerServer) NextLogBatch(grpc.ClientStreamingServer[Logs_NextBatchResp, emptypb.Empty]) error {
	return status.Errorf(codes.Unimplemented, "method NextLogBatch not implemented")
}
func (UnimplementedLogViewerServer) mustEmbedUnimplementedLogViewerServer() {}
func (UnimplementedLogViewerServer) testEmbeddedByValue()                   {}

// UnsafeLogViewerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogViewerServer will
// result in compilation errors.
type UnsafeLogViewerServer interface {
	mustEmbedUnimplementedLogViewerServer()
}

func RegisterLogViewerServer(s grpc.ServiceRegistrar, srv LogViewerServer) {
	// If the following call pancis, it indicates UnimplementedLogViewerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LogViewer_ServiceDesc, srv)
}

func _LogViewer_NextLogBatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LogViewerServer).NextLogBatch(&grpc.GenericServerStream[Logs_NextBatchResp, emptypb.Empty]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LogViewer_NextLogBatchServer = grpc.ClientStreamingServer[Logs_NextBatchResp, emptypb.Empty]

// LogViewer_ServiceDesc is the grpc.ServiceDesc for LogViewer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LogViewer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.LogViewer",
	HandlerType: (*LogViewerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NextLogBatch",
			Handler:       _LogViewer_NextLogBatch_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "plugin.proto",
}

const (
	TerminalUIService_Output_FullMethodName        = "/hashicorp.waypoint.sdk.TerminalUIService/Output"
	TerminalUIService_Events_FullMethodName        = "/hashicorp.waypoint.sdk.TerminalUIService/Events"
	TerminalUIService_IsInteractive_FullMethodName = "/hashicorp.waypoint.sdk.TerminalUIService/IsInteractive"
)

// TerminalUIServiceClient is the client API for TerminalUIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TerminalUIService is a service that provides "sdk/terminal.UI" interface
// to plugins. Plugins don't interact with this directly, they usually
// interact with it indirectly via a terminal.UI implementation.
type TerminalUIServiceClient interface {
	Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Events(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[TerminalUI_Event, TerminalUI_Response], error)
	IsInteractive(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error)
}

type terminalUIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTerminalUIServiceClient(cc grpc.ClientConnInterface) TerminalUIServiceClient {
	return &terminalUIServiceClient{cc}
}

func (c *terminalUIServiceClient) Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TerminalUIService_Output_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalUIServiceClient) Events(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[TerminalUI_Event, TerminalUI_Response], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TerminalUIService_ServiceDesc.Streams[0], TerminalUIService_Events_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TerminalUI_Event, TerminalUI_Response]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TerminalUIService_EventsClient = grpc.BidiStreamingClient[TerminalUI_Event, TerminalUI_Response]

func (c *terminalUIServiceClient) IsInteractive(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminalUI_IsInteractiveResponse)
	err := c.cc.Invoke(ctx, TerminalUIService_IsInteractive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TerminalUIServiceServer is the server API for TerminalUIService service.
// All implementations must embed UnimplementedTerminalUIServiceServer
// for forward compatibility.
//
// TerminalUIService is a service that provides "sdk/terminal.UI" interface
// to plugins. Plugins don't interact with this directly, they usually
// interact with it indirectly via a terminal.UI implementation.
type TerminalUIServiceServer interface {
	Output(context.Context, *TerminalUI_OutputRequest) (*emptypb.Empty, error)
	Events(grpc.BidiStreamingServer[TerminalUI_Event, TerminalUI_Response]) error
	IsInteractive(context.Context, *emptypb.Empty) (*TerminalUI_IsInteractiveResponse, error)
	mustEmbedUnimplementedTerminalUIServiceServer()
}

// UnimplementedTerminalUIServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTerminalUIServiceServer struct{}

func (UnimplementedTerminalUIServiceServer) Output(context.Context, *TerminalUI_OutputRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Output not implemented")
}
func (UnimplementedTerminalUIServiceServer) Events(grpc.BidiStreamingServer[TerminalUI_Event, TerminalUI_Response]) error {
	return status.Errorf(codes.Unimplemented, "method Events not implemented")
}
func (UnimplementedTerminalUIServiceServer) IsInteractive(context.Context, *emptypb.Empty) (*TerminalUI_IsInteractiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsInteractive not implemented")
}
func (UnimplementedTerminalUIServiceServer) mustEmbedUnimplementedTerminalUIServiceServer() {}
func (UnimplementedTerminalUIServiceServer) testEmbeddedByValue()                           {}

// UnsafeTerminalUIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TerminalUIServiceServer will
// result in compilation errors.
type UnsafeTerminalUIServiceServer interface {
	mustEmbedUnimplementedTerminalUIServiceServer()
}

func RegisterTerminalUIServiceServer(s grpc.ServiceRegistrar, srv TerminalUIServiceServer) {
	// If the following call pancis, it indicates UnimplementedTerminalUIServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TerminalUIService_ServiceDesc, srv)
}

func _TerminalUIService_Output_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminalUI_OutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).Output(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalUIService_Output_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).Output(ctx, req.(*TerminalUI_OutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalUIService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalUIServiceServer).Events(&grpc.GenericServerStream[TerminalUI_Event, TerminalUI_Response]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TerminalUIService_EventsServer = grpc.BidiStreamingServer[TerminalUI_Event, TerminalUI_Response]

func _TerminalUIService_IsInteractive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalUIService_IsInteractive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TerminalUIService_ServiceDesc is the grpc.ServiceDesc for TerminalUIService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TerminalUIService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.TerminalUIService",
	HandlerType: (*TerminalUIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Output",
			Handler:    _TerminalUIService_Output_Handler,
		},
		{
			MethodName: "IsInteractive",
			Handler:    _TerminalUIService_IsInteractive_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _TerminalUIService_Events_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "plugin.proto",
}

const (
	Mapper_ListMappers_FullMethodName = "/hashicorp.waypoint.sdk.Mapper/ListMappers"
	Mapper_Map_FullMethodName         = "/hashicorp.waypoint.sdk.Mapper/Map"
)

// MapperClient is the client API for Mapper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Mapper is a specialized type of plugin that provides type mappers
// to convert to/from various types.
type MapperClient interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error)
}

type mapperClient struct {
	cc grpc.ClientConnInterface
}

func NewMapperClient(cc grpc.ClientConnInterface) MapperClient {
	return &mapperClient{cc}
}

func (c *mapperClient) ListMappers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Map_ListResponse)
	err := c.cc.Invoke(ctx, Mapper_ListMappers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapperClient) Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Map_Response)
	err := c.cc.Invoke(ctx, Mapper_Map_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapperServer is the server API for Mapper service.
// All implementations must embed UnimplementedMapperServer
// for forward compatibility.
//
// Mapper is a specialized type of plugin that provides type mappers
// to convert to/from various types.
type MapperServer interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(context.Context, *emptypb.Empty) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(context.Context, *Map_Request) (*Map_Response, error)
	mustEmbedUnimplementedMapperServer()
}

// UnimplementedMapperServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMapperServer struct{}

func (UnimplementedMapperServer) ListMappers(context.Context, *emptypb.Empty) (*Map_ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMappers not implemented")
}
func (UnimplementedMapperServer) Map(context.Context, *Map_Request) (*Map_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Map not implemented")
}
func (UnimplementedMapperServer) mustEmbedUnimplementedMapperServer() {}
func (UnimplementedMapperServer) testEmbeddedByValue()                {}

// UnsafeMapperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MapperServer will
// result in compilation errors.
type UnsafeMapperServer interface {
	mustEmbedUnimplementedMapperServer()
}

func RegisterMapperServer(s grpc.ServiceRegistrar, srv MapperServer) {
	// If the following call pancis, it indicates UnimplementedMapperServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mapper_ServiceDesc, srv)
}

func _Mapper_ListMappers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).ListMappers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mapper_ListMappers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).ListMappers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mapper_Map_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Map_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).Map(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mapper_Map_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).Map(ctx, req.(*Map_Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Mapper_ServiceDesc is the grpc.ServiceDesc for Mapper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mapper_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.Mapper",
	HandlerType: (*MapperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMappers",
			Handler:    _Mapper_ListMappers_Handler,
		},
		{
			MethodName: "Map",
			Handler:    _Mapper_Map_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

const (
	Builder_IsAuthenticator_FullMethodName  = "/hashicorp.waypoint.sdk.Builder/IsAuthenticator"
	Builder_Auth_FullMethodName             = "/hashicorp.waypoint.sdk.Builder/Auth"
	Builder_AuthSpec_FullMethodName         = "/hashicorp.waypoint.sdk.Builder/AuthSpec"
	Builder_ValidateAuth_FullMethodName     = "/hashicorp.waypoint.sdk.Builder/ValidateAuth"
	Builder_ValidateAuthSpec_FullMethodName = "/hashicorp.waypoint.sdk.Builder/ValidateAuthSpec"
	Builder_ConfigStruct_FullMethodName     = "/hashicorp.waypoint.sdk.Builder/ConfigStruct"
	Builder_Configure_FullMethodName        = "/hashicorp.waypoint.sdk.Builder/Configure"
	Builder_Documentation_FullMethodName    = "/hashicorp.waypoint.sdk.Builder/Documentation"
	Builder_BuildSpec_FullMethodName        = "/hashicorp.waypoint.sdk.Builder/BuildSpec"
	Builder_Build_FullMethodName            = "/hashicorp.waypoint.sdk.Builder/Build"
	Builder_BuildODR_FullMethodName         = "/hashicorp.waypoint.sdk.Builder/BuildODR"
	Builder_BuildSpecODR_FullMethodName     = "/hashicorp.waypoint.sdk.Builder/BuildSpecODR"
)

// BuilderClient is the client API for Builder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Builder service is a builder that takes some set of arguments and produces
// an artifact.
type BuilderClient interface {
	IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error)
	AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	BuildSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Build(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Build_Resp, error)
	BuildODR(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Build_Resp, error)
	BuildSpecODR(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
}

type builderClient struct {
	cc grpc.ClientConnInterface
}

func NewBuilderClient(cc grpc.ClientConnInterface) BuilderClient {
	return &builderClient{cc}
}

func (c *builderClient) IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, Builder_IsAuthenticator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Auth_AuthResponse)
	err := c.cc.Invoke(ctx, Builder_Auth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Builder_AuthSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Builder_ValidateAuth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Builder_ValidateAuthSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, Builder_ConfigStruct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Builder_Configure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, Builder_Documentation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) BuildSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Builder_BuildSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) Build(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Build_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Build_Resp)
	err := c.cc.Invoke(ctx, Builder_Build_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) BuildODR(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Build_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Build_Resp)
	err := c.cc.Invoke(ctx, Builder_BuildODR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) BuildSpecODR(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Builder_BuildSpecODR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuilderServer is the server API for Builder service.
// All implementations must embed UnimplementedBuilderServer
// for forward compatibility.
//
// Builder service is a builder that takes some set of arguments and produces
// an artifact.
type BuilderServer interface {
	IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error)
	AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	BuildSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Build(context.Context, *FuncSpec_Args) (*Build_Resp, error)
	BuildODR(context.Context, *FuncSpec_Args) (*Build_Resp, error)
	BuildSpecODR(context.Context, *emptypb.Empty) (*FuncSpec, error)
	mustEmbedUnimplementedBuilderServer()
}

// UnimplementedBuilderServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBuilderServer struct{}

func (UnimplementedBuilderServer) IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAuthenticator not implemented")
}
func (UnimplementedBuilderServer) Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedBuilderServer) AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthSpec not implemented")
}
func (UnimplementedBuilderServer) ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuth not implemented")
}
func (UnimplementedBuilderServer) ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthSpec not implemented")
}
func (UnimplementedBuilderServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedBuilderServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedBuilderServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedBuilderServer) BuildSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildSpec not implemented")
}
func (UnimplementedBuilderServer) Build(context.Context, *FuncSpec_Args) (*Build_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Build not implemented")
}
func (UnimplementedBuilderServer) BuildODR(context.Context, *FuncSpec_Args) (*Build_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildODR not implemented")
}
func (UnimplementedBuilderServer) BuildSpecODR(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildSpecODR not implemented")
}
func (UnimplementedBuilderServer) mustEmbedUnimplementedBuilderServer() {}
func (UnimplementedBuilderServer) testEmbeddedByValue()                 {}

// UnsafeBuilderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuilderServer will
// result in compilation errors.
type UnsafeBuilderServer interface {
	mustEmbedUnimplementedBuilderServer()
}

func RegisterBuilderServer(s grpc.ServiceRegistrar, srv BuilderServer) {
	// If the following call pancis, it indicates UnimplementedBuilderServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Builder_ServiceDesc, srv)
}

func _Builder_IsAuthenticator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).IsAuthenticator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_IsAuthenticator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).IsAuthenticator(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_Auth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).Auth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_AuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).AuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_AuthSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).AuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_ValidateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).ValidateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_ValidateAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).ValidateAuth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_ValidateAuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).ValidateAuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_ValidateAuthSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).ValidateAuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_ConfigStruct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_Configure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_Documentation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_BuildSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).BuildSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_BuildSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).BuildSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_Build_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).Build(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_Build_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).Build(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_BuildODR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).BuildODR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_BuildODR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).BuildODR(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builder_BuildSpecODR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuilderServer).BuildSpecODR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builder_BuildSpecODR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuilderServer).BuildSpecODR(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Builder_ServiceDesc is the grpc.ServiceDesc for Builder service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Builder_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.Builder",
	HandlerType: (*BuilderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAuthenticator",
			Handler:    _Builder_IsAuthenticator_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _Builder_Auth_Handler,
		},
		{
			MethodName: "AuthSpec",
			Handler:    _Builder_AuthSpec_Handler,
		},
		{
			MethodName: "ValidateAuth",
			Handler:    _Builder_ValidateAuth_Handler,
		},
		{
			MethodName: "ValidateAuthSpec",
			Handler:    _Builder_ValidateAuthSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _Builder_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _Builder_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _Builder_Documentation_Handler,
		},
		{
			MethodName: "BuildSpec",
			Handler:    _Builder_BuildSpec_Handler,
		},
		{
			MethodName: "Build",
			Handler:    _Builder_Build_Handler,
		},
		{
			MethodName: "BuildODR",
			Handler:    _Builder_BuildODR_Handler,
		},
		{
			MethodName: "BuildSpecODR",
			Handler:    _Builder_BuildSpecODR_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

const (
	Platform_IsAuthenticator_FullMethodName      = "/hashicorp.waypoint.sdk.Platform/IsAuthenticator"
	Platform_Auth_FullMethodName                 = "/hashicorp.waypoint.sdk.Platform/Auth"
	Platform_AuthSpec_FullMethodName             = "/hashicorp.waypoint.sdk.Platform/AuthSpec"
	Platform_ValidateAuth_FullMethodName         = "/hashicorp.waypoint.sdk.Platform/ValidateAuth"
	Platform_ValidateAuthSpec_FullMethodName     = "/hashicorp.waypoint.sdk.Platform/ValidateAuthSpec"
	Platform_ConfigStruct_FullMethodName         = "/hashicorp.waypoint.sdk.Platform/ConfigStruct"
	Platform_Configure_FullMethodName            = "/hashicorp.waypoint.sdk.Platform/Configure"
	Platform_Documentation_FullMethodName        = "/hashicorp.waypoint.sdk.Platform/Documentation"
	Platform_DeploySpec_FullMethodName           = "/hashicorp.waypoint.sdk.Platform/DeploySpec"
	Platform_Deploy_FullMethodName               = "/hashicorp.waypoint.sdk.Platform/Deploy"
	Platform_DefaultReleaserSpec_FullMethodName  = "/hashicorp.waypoint.sdk.Platform/DefaultReleaserSpec"
	Platform_DefaultReleaser_FullMethodName      = "/hashicorp.waypoint.sdk.Platform/DefaultReleaser"
	Platform_IsDestroyer_FullMethodName          = "/hashicorp.waypoint.sdk.Platform/IsDestroyer"
	Platform_DestroySpec_FullMethodName          = "/hashicorp.waypoint.sdk.Platform/DestroySpec"
	Platform_Destroy_FullMethodName              = "/hashicorp.waypoint.sdk.Platform/Destroy"
	Platform_IsWorkspaceDestroyer_FullMethodName = "/hashicorp.waypoint.sdk.Platform/IsWorkspaceDestroyer"
	Platform_DestroyWorkspaceSpec_FullMethodName = "/hashicorp.waypoint.sdk.Platform/DestroyWorkspaceSpec"
	Platform_DestroyWorkspace_FullMethodName     = "/hashicorp.waypoint.sdk.Platform/DestroyWorkspace"
	Platform_IsExecer_FullMethodName             = "/hashicorp.waypoint.sdk.Platform/IsExecer"
	Platform_ExecSpec_FullMethodName             = "/hashicorp.waypoint.sdk.Platform/ExecSpec"
	Platform_Exec_FullMethodName                 = "/hashicorp.waypoint.sdk.Platform/Exec"
	Platform_IsLogPlatform_FullMethodName        = "/hashicorp.waypoint.sdk.Platform/IsLogPlatform"
	Platform_LogsSpec_FullMethodName             = "/hashicorp.waypoint.sdk.Platform/LogsSpec"
	Platform_Logs_FullMethodName                 = "/hashicorp.waypoint.sdk.Platform/Logs"
	Platform_IsGeneration_FullMethodName         = "/hashicorp.waypoint.sdk.Platform/IsGeneration"
	Platform_GenerationSpec_FullMethodName       = "/hashicorp.waypoint.sdk.Platform/GenerationSpec"
	Platform_Generation_FullMethodName           = "/hashicorp.waypoint.sdk.Platform/Generation"
	Platform_IsStatus_FullMethodName             = "/hashicorp.waypoint.sdk.Platform/IsStatus"
	Platform_StatusSpec_FullMethodName           = "/hashicorp.waypoint.sdk.Platform/StatusSpec"
	Platform_Status_FullMethodName               = "/hashicorp.waypoint.sdk.Platform/Status"
)

// PlatformClient is the client API for Platform service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Platform is responsible for deploying an artifact that is in a registry.
type PlatformClient interface {
	IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error)
	AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	DeploySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Deploy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Deploy_Resp, error)
	// component.PlatformReleaser optional implementation.
	DefaultReleaserSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	DefaultReleaser(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*DefaultReleaser_Resp, error)
	// component.Destroyer optional implementation
	IsDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	DestroySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Destroy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Destroy_Resp, error)
	// component.WorkspaceDestroyer optional implementation
	IsWorkspaceDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	DestroyWorkspaceSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	DestroyWorkspace(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// component.Execer optional implementation
	IsExecer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	ExecSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Exec(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*ExecResult, error)
	// component.LogViewer optional implementation
	// IsLogPlatform returns true if this platform also implements LogPlatform.
	IsLogPlatform(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	LogsSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Logs(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// component.Generation optional implementation
	IsGeneration(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	GenerationSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Generation(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Generation_Resp, error)
	// component.Status optional implementation
	IsStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	StatusSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Status(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*StatusReport, error)
}

type platformClient struct {
	cc grpc.ClientConnInterface
}

func NewPlatformClient(cc grpc.ClientConnInterface) PlatformClient {
	return &platformClient{cc}
}

func (c *platformClient) IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, Platform_IsAuthenticator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Auth_AuthResponse)
	err := c.cc.Invoke(ctx, Platform_Auth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_AuthSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Platform_ValidateAuth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_ValidateAuthSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, Platform_ConfigStruct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Platform_Configure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, Platform_Documentation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DeploySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_DeploySpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Deploy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Deploy_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Deploy_Resp)
	err := c.cc.Invoke(ctx, Platform_Deploy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DefaultReleaserSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_DefaultReleaserSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DefaultReleaser(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*DefaultReleaser_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DefaultReleaser_Resp)
	err := c.cc.Invoke(ctx, Platform_DefaultReleaser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, Platform_IsDestroyer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DestroySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_DestroySpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Destroy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Destroy_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Destroy_Resp)
	err := c.cc.Invoke(ctx, Platform_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsWorkspaceDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, Platform_IsWorkspaceDestroyer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DestroyWorkspaceSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_DestroyWorkspaceSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) DestroyWorkspace(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Platform_DestroyWorkspace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsExecer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, Platform_IsExecer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) ExecSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_ExecSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Exec(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*ExecResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecResult)
	err := c.cc.Invoke(ctx, Platform_Exec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsLogPlatform(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, Platform_IsLogPlatform_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) LogsSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_LogsSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Logs(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Platform_Logs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsGeneration(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, Platform_IsGeneration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) GenerationSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_GenerationSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Generation(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Generation_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Generation_Resp)
	err := c.cc.Invoke(ctx, Platform_Generation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) IsStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, Platform_IsStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) StatusSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Platform_StatusSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Status(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*StatusReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusReport)
	err := c.cc.Invoke(ctx, Platform_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlatformServer is the server API for Platform service.
// All implementations must embed UnimplementedPlatformServer
// for forward compatibility.
//
// Platform is responsible for deploying an artifact that is in a registry.
type PlatformServer interface {
	IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error)
	AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	DeploySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Deploy(context.Context, *FuncSpec_Args) (*Deploy_Resp, error)
	// component.PlatformReleaser optional implementation.
	DefaultReleaserSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	DefaultReleaser(context.Context, *FuncSpec_Args) (*DefaultReleaser_Resp, error)
	// component.Destroyer optional implementation
	IsDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	DestroySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Destroy(context.Context, *FuncSpec_Args) (*Destroy_Resp, error)
	// component.WorkspaceDestroyer optional implementation
	IsWorkspaceDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	DestroyWorkspaceSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	DestroyWorkspace(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	// component.Execer optional implementation
	IsExecer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	ExecSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Exec(context.Context, *FuncSpec_Args) (*ExecResult, error)
	// component.LogViewer optional implementation
	// IsLogPlatform returns true if this platform also implements LogPlatform.
	IsLogPlatform(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	LogsSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Logs(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	// component.Generation optional implementation
	IsGeneration(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	GenerationSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Generation(context.Context, *FuncSpec_Args) (*Generation_Resp, error)
	// component.Status optional implementation
	IsStatus(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	StatusSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Status(context.Context, *FuncSpec_Args) (*StatusReport, error)
	mustEmbedUnimplementedPlatformServer()
}

// UnimplementedPlatformServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPlatformServer struct{}

func (UnimplementedPlatformServer) IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAuthenticator not implemented")
}
func (UnimplementedPlatformServer) Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedPlatformServer) AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthSpec not implemented")
}
func (UnimplementedPlatformServer) ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuth not implemented")
}
func (UnimplementedPlatformServer) ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthSpec not implemented")
}
func (UnimplementedPlatformServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedPlatformServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedPlatformServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedPlatformServer) DeploySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeploySpec not implemented")
}
func (UnimplementedPlatformServer) Deploy(context.Context, *FuncSpec_Args) (*Deploy_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deploy not implemented")
}
func (UnimplementedPlatformServer) DefaultReleaserSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultReleaserSpec not implemented")
}
func (UnimplementedPlatformServer) DefaultReleaser(context.Context, *FuncSpec_Args) (*DefaultReleaser_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultReleaser not implemented")
}
func (UnimplementedPlatformServer) IsDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsDestroyer not implemented")
}
func (UnimplementedPlatformServer) DestroySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroySpec not implemented")
}
func (UnimplementedPlatformServer) Destroy(context.Context, *FuncSpec_Args) (*Destroy_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedPlatformServer) IsWorkspaceDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsWorkspaceDestroyer not implemented")
}
func (UnimplementedPlatformServer) DestroyWorkspaceSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorkspaceSpec not implemented")
}
func (UnimplementedPlatformServer) DestroyWorkspace(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorkspace not implemented")
}
func (UnimplementedPlatformServer) IsExecer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsExecer not implemented")
}
func (UnimplementedPlatformServer) ExecSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecSpec not implemented")
}
func (UnimplementedPlatformServer) Exec(context.Context, *FuncSpec_Args) (*ExecResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedPlatformServer) IsLogPlatform(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsLogPlatform not implemented")
}
func (UnimplementedPlatformServer) LogsSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogsSpec not implemented")
}
func (UnimplementedPlatformServer) Logs(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logs not implemented")
}
func (UnimplementedPlatformServer) IsGeneration(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsGeneration not implemented")
}
func (UnimplementedPlatformServer) GenerationSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerationSpec not implemented")
}
func (UnimplementedPlatformServer) Generation(context.Context, *FuncSpec_Args) (*Generation_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Generation not implemented")
}
func (UnimplementedPlatformServer) IsStatus(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsStatus not implemented")
}
func (UnimplementedPlatformServer) StatusSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusSpec not implemented")
}
func (UnimplementedPlatformServer) Status(context.Context, *FuncSpec_Args) (*StatusReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedPlatformServer) mustEmbedUnimplementedPlatformServer() {}
func (UnimplementedPlatformServer) testEmbeddedByValue()                  {}

// UnsafePlatformServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlatformServer will
// result in compilation errors.
type UnsafePlatformServer interface {
	mustEmbedUnimplementedPlatformServer()
}

func RegisterPlatformServer(s grpc.ServiceRegistrar, srv PlatformServer) {
	// If the following call pancis, it indicates UnimplementedPlatformServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Platform_ServiceDesc, srv)
}

func _Platform_IsAuthenticator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsAuthenticator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_IsAuthenticator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsAuthenticator(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_Auth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Auth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_AuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).AuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_AuthSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).AuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_ValidateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).ValidateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_ValidateAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).ValidateAuth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_ValidateAuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).ValidateAuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_ValidateAuthSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).ValidateAuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_ConfigStruct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_Configure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_Documentation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DeploySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DeploySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_DeploySpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DeploySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_Deploy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Deploy(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DefaultReleaserSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DefaultReleaserSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_DefaultReleaserSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DefaultReleaserSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DefaultReleaser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DefaultReleaser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_DefaultReleaser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DefaultReleaser(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsDestroyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsDestroyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_IsDestroyer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsDestroyer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DestroySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DestroySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_DestroySpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DestroySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Destroy(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsWorkspaceDestroyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsWorkspaceDestroyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_IsWorkspaceDestroyer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsWorkspaceDestroyer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DestroyWorkspaceSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DestroyWorkspaceSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_DestroyWorkspaceSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DestroyWorkspaceSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_DestroyWorkspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).DestroyWorkspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_DestroyWorkspace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).DestroyWorkspace(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsExecer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsExecer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_IsExecer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsExecer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_ExecSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).ExecSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_ExecSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).ExecSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Exec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Exec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_Exec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Exec(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsLogPlatform_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsLogPlatform(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_IsLogPlatform_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsLogPlatform(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_LogsSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).LogsSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_LogsSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).LogsSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Logs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Logs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_Logs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Logs(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsGeneration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsGeneration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_IsGeneration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsGeneration(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_GenerationSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).GenerationSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_GenerationSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).GenerationSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Generation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Generation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_Generation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Generation(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_IsStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).IsStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_IsStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).IsStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_StatusSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).StatusSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_StatusSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).StatusSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Platform_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Status(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// Platform_ServiceDesc is the grpc.ServiceDesc for Platform service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Platform_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.Platform",
	HandlerType: (*PlatformServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAuthenticator",
			Handler:    _Platform_IsAuthenticator_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _Platform_Auth_Handler,
		},
		{
			MethodName: "AuthSpec",
			Handler:    _Platform_AuthSpec_Handler,
		},
		{
			MethodName: "ValidateAuth",
			Handler:    _Platform_ValidateAuth_Handler,
		},
		{
			MethodName: "ValidateAuthSpec",
			Handler:    _Platform_ValidateAuthSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _Platform_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _Platform_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _Platform_Documentation_Handler,
		},
		{
			MethodName: "DeploySpec",
			Handler:    _Platform_DeploySpec_Handler,
		},
		{
			MethodName: "Deploy",
			Handler:    _Platform_Deploy_Handler,
		},
		{
			MethodName: "DefaultReleaserSpec",
			Handler:    _Platform_DefaultReleaserSpec_Handler,
		},
		{
			MethodName: "DefaultReleaser",
			Handler:    _Platform_DefaultReleaser_Handler,
		},
		{
			MethodName: "IsDestroyer",
			Handler:    _Platform_IsDestroyer_Handler,
		},
		{
			MethodName: "DestroySpec",
			Handler:    _Platform_DestroySpec_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _Platform_Destroy_Handler,
		},
		{
			MethodName: "IsWorkspaceDestroyer",
			Handler:    _Platform_IsWorkspaceDestroyer_Handler,
		},
		{
			MethodName: "DestroyWorkspaceSpec",
			Handler:    _Platform_DestroyWorkspaceSpec_Handler,
		},
		{
			MethodName: "DestroyWorkspace",
			Handler:    _Platform_DestroyWorkspace_Handler,
		},
		{
			MethodName: "IsExecer",
			Handler:    _Platform_IsExecer_Handler,
		},
		{
			MethodName: "ExecSpec",
			Handler:    _Platform_ExecSpec_Handler,
		},
		{
			MethodName: "Exec",
			Handler:    _Platform_Exec_Handler,
		},
		{
			MethodName: "IsLogPlatform",
			Handler:    _Platform_IsLogPlatform_Handler,
		},
		{
			MethodName: "LogsSpec",
			Handler:    _Platform_LogsSpec_Handler,
		},
		{
			MethodName: "Logs",
			Handler:    _Platform_Logs_Handler,
		},
		{
			MethodName: "IsGeneration",
			Handler:    _Platform_IsGeneration_Handler,
		},
		{
			MethodName: "GenerationSpec",
			Handler:    _Platform_GenerationSpec_Handler,
		},
		{
			MethodName: "Generation",
			Handler:    _Platform_Generation_Handler,
		},
		{
			MethodName: "IsStatus",
			Handler:    _Platform_IsStatus_Handler,
		},
		{
			MethodName: "StatusSpec",
			Handler:    _Platform_StatusSpec_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Platform_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

const (
	Registry_IsAuthenticator_FullMethodName  = "/hashicorp.waypoint.sdk.Registry/IsAuthenticator"
	Registry_Auth_FullMethodName             = "/hashicorp.waypoint.sdk.Registry/Auth"
	Registry_AuthSpec_FullMethodName         = "/hashicorp.waypoint.sdk.Registry/AuthSpec"
	Registry_ValidateAuth_FullMethodName     = "/hashicorp.waypoint.sdk.Registry/ValidateAuth"
	Registry_ValidateAuthSpec_FullMethodName = "/hashicorp.waypoint.sdk.Registry/ValidateAuthSpec"
	Registry_ConfigStruct_FullMethodName     = "/hashicorp.waypoint.sdk.Registry/ConfigStruct"
	Registry_Configure_FullMethodName        = "/hashicorp.waypoint.sdk.Registry/Configure"
	Registry_Documentation_FullMethodName    = "/hashicorp.waypoint.sdk.Registry/Documentation"
	Registry_PushSpec_FullMethodName         = "/hashicorp.waypoint.sdk.Registry/PushSpec"
	Registry_Push_FullMethodName             = "/hashicorp.waypoint.sdk.Registry/Push"
	Registry_AccessSpec_FullMethodName       = "/hashicorp.waypoint.sdk.Registry/AccessSpec"
	Registry_Access_FullMethodName           = "/hashicorp.waypoint.sdk.Registry/Access"
)

// RegistryClient is the client API for Registry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Registry is responsible for pushing a built artifact to some registry.
// The difference between a registry and a builder is that while a builder
// produces an artifact from source, a registry provides operations to work
// with artifacts such as listing previous, deleting, etc.
type RegistryClient interface {
	IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error)
	AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	PushSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Push(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Push_Resp, error)
	// Access and AccessSpec are used to provide the optional component.RegistryAccess
	// interface.
	AccessSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Access(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Access_Resp, error)
}

type registryClient struct {
	cc grpc.ClientConnInterface
}

func NewRegistryClient(cc grpc.ClientConnInterface) RegistryClient {
	return &registryClient{cc}
}

func (c *registryClient) IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, Registry_IsAuthenticator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Auth_AuthResponse)
	err := c.cc.Invoke(ctx, Registry_Auth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Registry_AuthSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Registry_ValidateAuth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Registry_ValidateAuthSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, Registry_ConfigStruct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Registry_Configure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, Registry_Documentation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) PushSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Registry_PushSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Push(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Push_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Push_Resp)
	err := c.cc.Invoke(ctx, Registry_Push_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) AccessSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, Registry_AccessSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) Access(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Access_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Access_Resp)
	err := c.cc.Invoke(ctx, Registry_Access_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegistryServer is the server API for Registry service.
// All implementations must embed UnimplementedRegistryServer
// for forward compatibility.
//
// Registry is responsible for pushing a built artifact to some registry.
// The difference between a registry and a builder is that while a builder
// produces an artifact from source, a registry provides operations to work
// with artifacts such as listing previous, deleting, etc.
type RegistryServer interface {
	IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error)
	AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	PushSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Push(context.Context, *FuncSpec_Args) (*Push_Resp, error)
	// Access and AccessSpec are used to provide the optional component.RegistryAccess
	// interface.
	AccessSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Access(context.Context, *FuncSpec_Args) (*Access_Resp, error)
	mustEmbedUnimplementedRegistryServer()
}

// UnimplementedRegistryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRegistryServer struct{}

func (UnimplementedRegistryServer) IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAuthenticator not implemented")
}
func (UnimplementedRegistryServer) Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedRegistryServer) AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthSpec not implemented")
}
func (UnimplementedRegistryServer) ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuth not implemented")
}
func (UnimplementedRegistryServer) ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthSpec not implemented")
}
func (UnimplementedRegistryServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedRegistryServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedRegistryServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedRegistryServer) PushSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushSpec not implemented")
}
func (UnimplementedRegistryServer) Push(context.Context, *FuncSpec_Args) (*Push_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedRegistryServer) AccessSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessSpec not implemented")
}
func (UnimplementedRegistryServer) Access(context.Context, *FuncSpec_Args) (*Access_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Access not implemented")
}
func (UnimplementedRegistryServer) mustEmbedUnimplementedRegistryServer() {}
func (UnimplementedRegistryServer) testEmbeddedByValue()                  {}

// UnsafeRegistryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegistryServer will
// result in compilation errors.
type UnsafeRegistryServer interface {
	mustEmbedUnimplementedRegistryServer()
}

func RegisterRegistryServer(s grpc.ServiceRegistrar, srv RegistryServer) {
	// If the following call pancis, it indicates UnimplementedRegistryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Registry_ServiceDesc, srv)
}

func _Registry_IsAuthenticator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).IsAuthenticator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_IsAuthenticator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).IsAuthenticator(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_Auth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Auth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_AuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).AuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_AuthSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).AuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_ValidateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).ValidateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_ValidateAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).ValidateAuth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_ValidateAuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).ValidateAuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_ValidateAuthSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).ValidateAuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_ConfigStruct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_Configure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_Documentation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_PushSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).PushSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_PushSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).PushSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_Push_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Push(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_AccessSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).AccessSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_AccessSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).AccessSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_Access_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).Access(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Registry_Access_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).Access(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// Registry_ServiceDesc is the grpc.ServiceDesc for Registry service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Registry_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.Registry",
	HandlerType: (*RegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAuthenticator",
			Handler:    _Registry_IsAuthenticator_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _Registry_Auth_Handler,
		},
		{
			MethodName: "AuthSpec",
			Handler:    _Registry_AuthSpec_Handler,
		},
		{
			MethodName: "ValidateAuth",
			Handler:    _Registry_ValidateAuth_Handler,
		},
		{
			MethodName: "ValidateAuthSpec",
			Handler:    _Registry_ValidateAuthSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _Registry_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _Registry_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _Registry_Documentation_Handler,
		},
		{
			MethodName: "PushSpec",
			Handler:    _Registry_PushSpec_Handler,
		},
		{
			MethodName: "Push",
			Handler:    _Registry_Push_Handler,
		},
		{
			MethodName: "AccessSpec",
			Handler:    _Registry_AccessSpec_Handler,
		},
		{
			MethodName: "Access",
			Handler:    _Registry_Access_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

const (
	ReleaseManager_IsAuthenticator_FullMethodName      = "/hashicorp.waypoint.sdk.ReleaseManager/IsAuthenticator"
	ReleaseManager_Auth_FullMethodName                 = "/hashicorp.waypoint.sdk.ReleaseManager/Auth"
	ReleaseManager_AuthSpec_FullMethodName             = "/hashicorp.waypoint.sdk.ReleaseManager/AuthSpec"
	ReleaseManager_ValidateAuth_FullMethodName         = "/hashicorp.waypoint.sdk.ReleaseManager/ValidateAuth"
	ReleaseManager_ValidateAuthSpec_FullMethodName     = "/hashicorp.waypoint.sdk.ReleaseManager/ValidateAuthSpec"
	ReleaseManager_ConfigStruct_FullMethodName         = "/hashicorp.waypoint.sdk.ReleaseManager/ConfigStruct"
	ReleaseManager_Configure_FullMethodName            = "/hashicorp.waypoint.sdk.ReleaseManager/Configure"
	ReleaseManager_Documentation_FullMethodName        = "/hashicorp.waypoint.sdk.ReleaseManager/Documentation"
	ReleaseManager_IsDestroyer_FullMethodName          = "/hashicorp.waypoint.sdk.ReleaseManager/IsDestroyer"
	ReleaseManager_DestroySpec_FullMethodName          = "/hashicorp.waypoint.sdk.ReleaseManager/DestroySpec"
	ReleaseManager_Destroy_FullMethodName              = "/hashicorp.waypoint.sdk.ReleaseManager/Destroy"
	ReleaseManager_IsWorkspaceDestroyer_FullMethodName = "/hashicorp.waypoint.sdk.ReleaseManager/IsWorkspaceDestroyer"
	ReleaseManager_DestroyWorkspaceSpec_FullMethodName = "/hashicorp.waypoint.sdk.ReleaseManager/DestroyWorkspaceSpec"
	ReleaseManager_DestroyWorkspace_FullMethodName     = "/hashicorp.waypoint.sdk.ReleaseManager/DestroyWorkspace"
	ReleaseManager_ReleaseSpec_FullMethodName          = "/hashicorp.waypoint.sdk.ReleaseManager/ReleaseSpec"
	ReleaseManager_Release_FullMethodName              = "/hashicorp.waypoint.sdk.ReleaseManager/Release"
	ReleaseManager_IsStatus_FullMethodName             = "/hashicorp.waypoint.sdk.ReleaseManager/IsStatus"
	ReleaseManager_StatusSpec_FullMethodName           = "/hashicorp.waypoint.sdk.ReleaseManager/StatusSpec"
	ReleaseManager_Status_FullMethodName               = "/hashicorp.waypoint.sdk.ReleaseManager/Status"
)

// ReleaseManagerClient is the client API for ReleaseManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ReleaseManager is a service that handles the process of exposing
// a deployment to traffic.
type ReleaseManagerClient interface {
	IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error)
	AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	// component.Destroyer optional implementation
	IsDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	DestroySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Destroy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Destroy_Resp, error)
	// component.WorkspaceDestroyer optional implementation
	IsWorkspaceDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	DestroyWorkspaceSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	DestroyWorkspace(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ReleaseSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Release(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Release_Resp, error)
	// component.Status optional implementation
	IsStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error)
	StatusSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Status(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*StatusReport, error)
}

type releaseManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewReleaseManagerClient(cc grpc.ClientConnInterface) ReleaseManagerClient {
	return &releaseManagerClient{cc}
}

func (c *releaseManagerClient) IsAuthenticator(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, ReleaseManager_IsAuthenticator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Auth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Auth_AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Auth_AuthResponse)
	err := c.cc.Invoke(ctx, ReleaseManager_Auth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) AuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, ReleaseManager_AuthSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) ValidateAuth(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReleaseManager_ValidateAuth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) ValidateAuthSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, ReleaseManager_ValidateAuthSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, ReleaseManager_ConfigStruct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReleaseManager_Configure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, ReleaseManager_Documentation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) IsDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, ReleaseManager_IsDestroyer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) DestroySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, ReleaseManager_DestroySpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Destroy(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Destroy_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Destroy_Resp)
	err := c.cc.Invoke(ctx, ReleaseManager_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) IsWorkspaceDestroyer(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, ReleaseManager_IsWorkspaceDestroyer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) DestroyWorkspaceSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, ReleaseManager_DestroyWorkspaceSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) DestroyWorkspace(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReleaseManager_DestroyWorkspace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) ReleaseSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, ReleaseManager_ReleaseSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Release(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Release_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Release_Resp)
	err := c.cc.Invoke(ctx, ReleaseManager_Release_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) IsStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ImplementsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementsResp)
	err := c.cc.Invoke(ctx, ReleaseManager_IsStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) StatusSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, ReleaseManager_StatusSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseManagerClient) Status(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*StatusReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusReport)
	err := c.cc.Invoke(ctx, ReleaseManager_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReleaseManagerServer is the server API for ReleaseManager service.
// All implementations must embed UnimplementedReleaseManagerServer
// for forward compatibility.
//
// ReleaseManager is a service that handles the process of exposing
// a deployment to traffic.
type ReleaseManagerServer interface {
	IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error)
	AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	// component.Destroyer optional implementation
	IsDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	DestroySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Destroy(context.Context, *FuncSpec_Args) (*Destroy_Resp, error)
	// component.WorkspaceDestroyer optional implementation
	IsWorkspaceDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	DestroyWorkspaceSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	DestroyWorkspace(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ReleaseSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Release(context.Context, *FuncSpec_Args) (*Release_Resp, error)
	// component.Status optional implementation
	IsStatus(context.Context, *emptypb.Empty) (*ImplementsResp, error)
	StatusSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Status(context.Context, *FuncSpec_Args) (*StatusReport, error)
	mustEmbedUnimplementedReleaseManagerServer()
}

// UnimplementedReleaseManagerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReleaseManagerServer struct{}

func (UnimplementedReleaseManagerServer) IsAuthenticator(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAuthenticator not implemented")
}
func (UnimplementedReleaseManagerServer) Auth(context.Context, *FuncSpec_Args) (*Auth_AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedReleaseManagerServer) AuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthSpec not implemented")
}
func (UnimplementedReleaseManagerServer) ValidateAuth(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuth not implemented")
}
func (UnimplementedReleaseManagerServer) ValidateAuthSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthSpec not implemented")
}
func (UnimplementedReleaseManagerServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedReleaseManagerServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedReleaseManagerServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedReleaseManagerServer) IsDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsDestroyer not implemented")
}
func (UnimplementedReleaseManagerServer) DestroySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroySpec not implemented")
}
func (UnimplementedReleaseManagerServer) Destroy(context.Context, *FuncSpec_Args) (*Destroy_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedReleaseManagerServer) IsWorkspaceDestroyer(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsWorkspaceDestroyer not implemented")
}
func (UnimplementedReleaseManagerServer) DestroyWorkspaceSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorkspaceSpec not implemented")
}
func (UnimplementedReleaseManagerServer) DestroyWorkspace(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorkspace not implemented")
}
func (UnimplementedReleaseManagerServer) ReleaseSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseSpec not implemented")
}
func (UnimplementedReleaseManagerServer) Release(context.Context, *FuncSpec_Args) (*Release_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Release not implemented")
}
func (UnimplementedReleaseManagerServer) IsStatus(context.Context, *emptypb.Empty) (*ImplementsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsStatus not implemented")
}
func (UnimplementedReleaseManagerServer) StatusSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusSpec not implemented")
}
func (UnimplementedReleaseManagerServer) Status(context.Context, *FuncSpec_Args) (*StatusReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedReleaseManagerServer) mustEmbedUnimplementedReleaseManagerServer() {}
func (UnimplementedReleaseManagerServer) testEmbeddedByValue()                        {}

// UnsafeReleaseManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReleaseManagerServer will
// result in compilation errors.
type UnsafeReleaseManagerServer interface {
	mustEmbedUnimplementedReleaseManagerServer()
}

func RegisterReleaseManagerServer(s grpc.ServiceRegistrar, srv ReleaseManagerServer) {
	// If the following call pancis, it indicates UnimplementedReleaseManagerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReleaseManager_ServiceDesc, srv)
}

func _ReleaseManager_IsAuthenticator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).IsAuthenticator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_IsAuthenticator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).IsAuthenticator(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_Auth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Auth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_AuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).AuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_AuthSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).AuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_ValidateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).ValidateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_ValidateAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).ValidateAuth(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_ValidateAuthSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).ValidateAuthSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_ValidateAuthSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).ValidateAuthSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_ConfigStruct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_Configure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_Documentation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_IsDestroyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).IsDestroyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_IsDestroyer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).IsDestroyer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_DestroySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).DestroySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_DestroySpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).DestroySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Destroy(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_IsWorkspaceDestroyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).IsWorkspaceDestroyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_IsWorkspaceDestroyer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).IsWorkspaceDestroyer(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_DestroyWorkspaceSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).DestroyWorkspaceSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_DestroyWorkspaceSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).DestroyWorkspaceSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_DestroyWorkspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).DestroyWorkspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_DestroyWorkspace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).DestroyWorkspace(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_ReleaseSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).ReleaseSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_ReleaseSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).ReleaseSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Release_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Release(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_Release_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Release(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_IsStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).IsStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_IsStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).IsStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_StatusSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).StatusSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_StatusSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).StatusSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseManager_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseManagerServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReleaseManager_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseManagerServer).Status(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// ReleaseManager_ServiceDesc is the grpc.ServiceDesc for ReleaseManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReleaseManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.ReleaseManager",
	HandlerType: (*ReleaseManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAuthenticator",
			Handler:    _ReleaseManager_IsAuthenticator_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _ReleaseManager_Auth_Handler,
		},
		{
			MethodName: "AuthSpec",
			Handler:    _ReleaseManager_AuthSpec_Handler,
		},
		{
			MethodName: "ValidateAuth",
			Handler:    _ReleaseManager_ValidateAuth_Handler,
		},
		{
			MethodName: "ValidateAuthSpec",
			Handler:    _ReleaseManager_ValidateAuthSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _ReleaseManager_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ReleaseManager_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ReleaseManager_Documentation_Handler,
		},
		{
			MethodName: "IsDestroyer",
			Handler:    _ReleaseManager_IsDestroyer_Handler,
		},
		{
			MethodName: "DestroySpec",
			Handler:    _ReleaseManager_DestroySpec_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _ReleaseManager_Destroy_Handler,
		},
		{
			MethodName: "IsWorkspaceDestroyer",
			Handler:    _ReleaseManager_IsWorkspaceDestroyer_Handler,
		},
		{
			MethodName: "DestroyWorkspaceSpec",
			Handler:    _ReleaseManager_DestroyWorkspaceSpec_Handler,
		},
		{
			MethodName: "DestroyWorkspace",
			Handler:    _ReleaseManager_DestroyWorkspace_Handler,
		},
		{
			MethodName: "ReleaseSpec",
			Handler:    _ReleaseManager_ReleaseSpec_Handler,
		},
		{
			MethodName: "Release",
			Handler:    _ReleaseManager_Release_Handler,
		},
		{
			MethodName: "IsStatus",
			Handler:    _ReleaseManager_IsStatus_Handler,
		},
		{
			MethodName: "StatusSpec",
			Handler:    _ReleaseManager_StatusSpec_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _ReleaseManager_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

const (
	ConfigSourcer_ConfigStruct_FullMethodName  = "/hashicorp.waypoint.sdk.ConfigSourcer/ConfigStruct"
	ConfigSourcer_Configure_FullMethodName     = "/hashicorp.waypoint.sdk.ConfigSourcer/Configure"
	ConfigSourcer_Documentation_FullMethodName = "/hashicorp.waypoint.sdk.ConfigSourcer/Documentation"
	ConfigSourcer_ReadSpec_FullMethodName      = "/hashicorp.waypoint.sdk.ConfigSourcer/ReadSpec"
	ConfigSourcer_Read_FullMethodName          = "/hashicorp.waypoint.sdk.ConfigSourcer/Read"
	ConfigSourcer_StopSpec_FullMethodName      = "/hashicorp.waypoint.sdk.ConfigSourcer/StopSpec"
	ConfigSourcer_Stop_FullMethodName          = "/hashicorp.waypoint.sdk.ConfigSourcer/Stop"
)

// ConfigSourcerClient is the client API for ConfigSourcer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ConfigSourcer is a service that reads configuration for the application.
type ConfigSourcerClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	ReadSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Read(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*ConfigSource_ReadResponse, error)
	StopSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Stop(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type configSourcerClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigSourcerClient(cc grpc.ClientConnInterface) ConfigSourcerClient {
	return &configSourcerClient{cc}
}

func (c *configSourcerClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, ConfigSourcer_ConfigStruct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ConfigSourcer_Configure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, ConfigSourcer_Documentation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) ReadSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, ConfigSourcer_ReadSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) Read(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*ConfigSource_ReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigSource_ReadResponse)
	err := c.cc.Invoke(ctx, ConfigSourcer_Read_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) StopSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, ConfigSourcer_StopSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configSourcerClient) Stop(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ConfigSourcer_Stop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigSourcerServer is the server API for ConfigSourcer service.
// All implementations must embed UnimplementedConfigSourcerServer
// for forward compatibility.
//
// ConfigSourcer is a service that reads configuration for the application.
type ConfigSourcerServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	ReadSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Read(context.Context, *FuncSpec_Args) (*ConfigSource_ReadResponse, error)
	StopSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Stop(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	mustEmbedUnimplementedConfigSourcerServer()
}

// UnimplementedConfigSourcerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConfigSourcerServer struct{}

func (UnimplementedConfigSourcerServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedConfigSourcerServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedConfigSourcerServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedConfigSourcerServer) ReadSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadSpec not implemented")
}
func (UnimplementedConfigSourcerServer) Read(context.Context, *FuncSpec_Args) (*ConfigSource_ReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedConfigSourcerServer) StopSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopSpec not implemented")
}
func (UnimplementedConfigSourcerServer) Stop(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedConfigSourcerServer) mustEmbedUnimplementedConfigSourcerServer() {}
func (UnimplementedConfigSourcerServer) testEmbeddedByValue()                       {}

// UnsafeConfigSourcerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigSourcerServer will
// result in compilation errors.
type UnsafeConfigSourcerServer interface {
	mustEmbedUnimplementedConfigSourcerServer()
}

func RegisterConfigSourcerServer(s grpc.ServiceRegistrar, srv ConfigSourcerServer) {
	// If the following call pancis, it indicates UnimplementedConfigSourcerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConfigSourcer_ServiceDesc, srv)
}

func _ConfigSourcer_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigSourcer_ConfigStruct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigSourcer_Configure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigSourcer_Documentation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_ReadSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).ReadSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigSourcer_ReadSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).ReadSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigSourcer_Read_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).Read(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_StopSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).StopSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigSourcer_StopSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).StopSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigSourcer_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigSourcerServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigSourcer_Stop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigSourcerServer).Stop(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigSourcer_ServiceDesc is the grpc.ServiceDesc for ConfigSourcer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfigSourcer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.ConfigSourcer",
	HandlerType: (*ConfigSourcerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _ConfigSourcer_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ConfigSourcer_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ConfigSourcer_Documentation_Handler,
		},
		{
			MethodName: "ReadSpec",
			Handler:    _ConfigSourcer_ReadSpec_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _ConfigSourcer_Read_Handler,
		},
		{
			MethodName: "StopSpec",
			Handler:    _ConfigSourcer_StopSpec_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ConfigSourcer_Stop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

const (
	TaskLauncher_ConfigStruct_FullMethodName  = "/hashicorp.waypoint.sdk.TaskLauncher/ConfigStruct"
	TaskLauncher_Configure_FullMethodName     = "/hashicorp.waypoint.sdk.TaskLauncher/Configure"
	TaskLauncher_Documentation_FullMethodName = "/hashicorp.waypoint.sdk.TaskLauncher/Documentation"
	TaskLauncher_StartSpec_FullMethodName     = "/hashicorp.waypoint.sdk.TaskLauncher/StartSpec"
	TaskLauncher_StopSpec_FullMethodName      = "/hashicorp.waypoint.sdk.TaskLauncher/StopSpec"
	TaskLauncher_WatchSpec_FullMethodName     = "/hashicorp.waypoint.sdk.TaskLauncher/WatchSpec"
	TaskLauncher_StartTask_FullMethodName     = "/hashicorp.waypoint.sdk.TaskLauncher/StartTask"
	TaskLauncher_StopTask_FullMethodName      = "/hashicorp.waypoint.sdk.TaskLauncher/StopTask"
	TaskLauncher_WatchTask_FullMethodName     = "/hashicorp.waypoint.sdk.TaskLauncher/WatchTask"
)

// TaskLauncherClient is the client API for TaskLauncher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TaskLauncher service to start and stop tasks (activities spawned from
// oci images that run until completion and are not restarted) that take
// some set of arguments and returns its identification state.
type TaskLauncherClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	StartSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	StopSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	WatchSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	StartTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*TaskLaunch_Resp, error)
	StopTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	WatchTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*TaskWatch_Resp, error)
}

type taskLauncherClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskLauncherClient(cc grpc.ClientConnInterface) TaskLauncherClient {
	return &taskLauncherClient{cc}
}

func (c *taskLauncherClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, TaskLauncher_ConfigStruct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TaskLauncher_Configure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, TaskLauncher_Documentation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) StartSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, TaskLauncher_StartSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) StopSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, TaskLauncher_StopSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) WatchSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, TaskLauncher_WatchSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) StartTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*TaskLaunch_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskLaunch_Resp)
	err := c.cc.Invoke(ctx, TaskLauncher_StartTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) StopTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TaskLauncher_StopTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskLauncherClient) WatchTask(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*TaskWatch_Resp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskWatch_Resp)
	err := c.cc.Invoke(ctx, TaskLauncher_WatchTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskLauncherServer is the server API for TaskLauncher service.
// All implementations must embed UnimplementedTaskLauncherServer
// for forward compatibility.
//
// TaskLauncher service to start and stop tasks (activities spawned from
// oci images that run until completion and are not restarted) that take
// some set of arguments and returns its identification state.
type TaskLauncherServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	StartSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	StopSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	WatchSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	StartTask(context.Context, *FuncSpec_Args) (*TaskLaunch_Resp, error)
	StopTask(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	WatchTask(context.Context, *FuncSpec_Args) (*TaskWatch_Resp, error)
	mustEmbedUnimplementedTaskLauncherServer()
}

// UnimplementedTaskLauncherServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskLauncherServer struct{}

func (UnimplementedTaskLauncherServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedTaskLauncherServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedTaskLauncherServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedTaskLauncherServer) StartSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartSpec not implemented")
}
func (UnimplementedTaskLauncherServer) StopSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopSpec not implemented")
}
func (UnimplementedTaskLauncherServer) WatchSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WatchSpec not implemented")
}
func (UnimplementedTaskLauncherServer) StartTask(context.Context, *FuncSpec_Args) (*TaskLaunch_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTask not implemented")
}
func (UnimplementedTaskLauncherServer) StopTask(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopTask not implemented")
}
func (UnimplementedTaskLauncherServer) WatchTask(context.Context, *FuncSpec_Args) (*TaskWatch_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WatchTask not implemented")
}
func (UnimplementedTaskLauncherServer) mustEmbedUnimplementedTaskLauncherServer() {}
func (UnimplementedTaskLauncherServer) testEmbeddedByValue()                      {}

// UnsafeTaskLauncherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskLauncherServer will
// result in compilation errors.
type UnsafeTaskLauncherServer interface {
	mustEmbedUnimplementedTaskLauncherServer()
}

func RegisterTaskLauncherServer(s grpc.ServiceRegistrar, srv TaskLauncherServer) {
	// If the following call pancis, it indicates UnimplementedTaskLauncherServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TaskLauncher_ServiceDesc, srv)
}

func _TaskLauncher_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskLauncher_ConfigStruct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskLauncher_Configure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskLauncher_Documentation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_StartSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).StartSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskLauncher_StartSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).StartSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_StopSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).StopSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskLauncher_StopSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).StopSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_WatchSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).WatchSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskLauncher_WatchSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).WatchSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).StartTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskLauncher_StartTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).StartTask(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_StopTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).StopTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskLauncher_StopTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).StopTask(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskLauncher_WatchTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskLauncherServer).WatchTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskLauncher_WatchTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskLauncherServer).WatchTask(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskLauncher_ServiceDesc is the grpc.ServiceDesc for TaskLauncher service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskLauncher_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.waypoint.sdk.TaskLauncher",
	HandlerType: (*TaskLauncherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _TaskLauncher_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _TaskLauncher_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _TaskLauncher_Documentation_Handler,
		},
		{
			MethodName: "StartSpec",
			Handler:    _TaskLauncher_StartSpec_Handler,
		},
		{
			MethodName: "StopSpec",
			Handler:    _TaskLauncher_StopSpec_Handler,
		},
		{
			MethodName: "WatchSpec",
			Handler:    _TaskLauncher_WatchSpec_Handler,
		},
		{
			MethodName: "StartTask",
			Handler:    _TaskLauncher_StartTask_Handler,
		},
		{
			MethodName: "StopTask",
			Handler:    _TaskLauncher_StopTask_Handler,
		},
		{
			MethodName: "WatchTask",
			Handler:    _TaskLauncher_WatchTask_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}
